library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls(all.names = TRUE))
gc()
df <- read_excel("Datos\\data_uruguay_tp2.xlsx")
df <- read_excel("data_uruguay_tp2.xlsx")
df <- read_excel("/Users/ninadicostanzopereira/Desktop/MacroMetrics/MacroEconometria/TP2/data_uruguay_tp2.xlsx")
library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls(all.names = TRUE))
gc()
###Creo PBI no agro y CCNN per capita
df <- df %>%
mutate(
gdp_resto    = gdp_total - gdp_agro,
gdp_total_pc = gdp_total / pop,
gdp_agro_pc  = gdp_agro / pop,
gdp_resto_pc = gdp_resto / pop,
cons_pc      = cons / pop,
invest_pc    = invest / pop
)
df <- read_excel("data_uruguay_tp2.xlsx")
###Creo PBI no agro y CCNN per capita
df <- df %>%
mutate(
gdp_resto    = gdp_total - gdp_agro,
gdp_total_pc = gdp_total / pop,
gdp_agro_pc  = gdp_agro / pop,
gdp_resto_pc = gdp_resto / pop,
cons_pc      = cons / pop,
invest_pc    = invest / pop
)
###Me quedo solo con las variables pc y convierto a time series
df <- df[, c("gdp_total_pc", "gdp_agro_pc", "gdp_resto_pc", "cons_pc", "invest_pc", "reer", "smdi", "gdp_socios", "employment")]
datos_ts <- ts(df, start = c(2005, 1), frequency = 4)
###Desestacionalización
datos_sa <- datos_ts
cols_no_deseason <- c("reer", "gdp_socios", "smdi") #defino cuáles no desest
for (col in colnames(datos_ts)) {
serie <- datos_ts[, col]
if (col %in% cols_no_deseason) {
# No desestacionalizar → dejar tal cual
datos_sa[, col] <- serie
} else {
# Intentar desestacionalizar con seas()
seas.adj <- seas(serie)
x.sa <- seas.adj$series$s11
datos_sa[, col] <- x.sa
}
}
### Transformar a log × 100 (excluyendo smdi)
cols_to_log <- setdiff(colnames(datos_sa), "smdi")
for (col in cols_to_log) {
datos_sa[, col] <- log(datos_sa[, col]) * 100
}
###Filtro HP (excepto smdi)
cols_to_filter <- setdiff(colnames(datos_sa), "smdi")
datos_hp_cycle <- datos_sa  # Copiar estructura
for (col in cols_to_filter) {
hp_result <- hpfilter(datos_sa[, col], freq = 1600)
datos_hp_cycle[, col] <- hp_result$cycle
}
install.packages("mFilter")
library(mFilter)
### Transformar a log × 100 (excluyendo smdi)
cols_to_log <- setdiff(colnames(datos_sa), "smdi")
for (col in cols_to_log) {
datos_sa[, col] <- log(datos_sa[, col]) * 100
}
###Filtro HP (excepto smdi)
cols_to_filter <- setdiff(colnames(datos_sa), "smdi")
datos_hp_cycle <- datos_sa  # Copiar estructura
for (col in cols_to_filter) {
hp_result <- hpfilter(datos_sa[, col], freq = 1600)
datos_hp_cycle[, col] <- hp_result$cycle
}
view(df)
install.packages("seasonalview")
view(df)
View(df)
#install.packages("mFilter")
#install.packages("seasonalview")
library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls(all.names = TRUE))
gc()
df <- read_excel("data_uruguay_tp2.xlsx")
###Creo PBI no agro y CCNN per capita
df <- df %>%
mutate(
gdp_resto    = gdp_total - gdp_agro,
gdp_total_pc = gdp_total / pop,
gdp_agro_pc  = gdp_agro / pop,
gdp_resto_pc = gdp_resto / pop,
cons_pc      = cons / pop,
invest_pc    = invest / pop
)
###Me quedo solo con las variables pc y convierto a time series
df <- df[, c("gdp_total_pc", "gdp_agro_pc", "gdp_resto_pc", "cons_pc", "invest_pc", "reer", "smdi", "gdp_socios", "employment")]
datos_ts <- ts(df, start = c(2005, 1), frequency = 4)
###Desestacionalización
datos_sa <- datos_ts
cols_no_deseason <- c("reer", "gdp_socios", "smdi") #defino cuáles no desest
for (col in colnames(datos_ts)) {
serie <- datos_ts[, col]
if (col %in% cols_no_deseason) {
# No desestacionalizar → dejar tal cual
datos_sa[, col] <- serie
} else {
# Intentar desestacionalizar con seas()
seas.adj <- seas(serie)
x.sa <- seas.adj$series$s11
datos_sa[, col] <- x.sa
}
}
### Transformar a log × 100 (excluyendo smdi)
cols_to_log <- setdiff(colnames(datos_sa), "smdi")
for (col in cols_to_log) {
datos_sa[, col] <- log(datos_sa[, col]) * 100
}
###Filtro HP (excepto smdi)
cols_to_filter <- setdiff(colnames(datos_sa), "smdi")
datos_hp_cycle <- datos_sa  # Copiar estructura
for (col in cols_to_filter) {
hp_result <- hpfilter(datos_sa[, col], freq = 1600)
datos_hp_cycle[, col] <- hp_result$cycle
}
source("TP2.2_Procesamiento.R")
#install.packages("mFilter")
#install.packages("seasonalview")
library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#install.packages("mFilter")
#install.packages("seasonalview")
library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
#install.packages("mFilter")
#install.packages("seasonalview")
library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls(all.names = TRUE))
gc()
#importo lo otro
source("TP2.2_Procesamiento.R")
#install.packages("mFilter")
#install.packages("seasonalview")
library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls(all.names = TRUE))
gc()
#importo lo otro
source("TP2.2_Procesamiento.R")
datos_hp_cycle
library(vars)
df_var <- cbind(
smdi               = datos_sa[, "smdi"],
gdp_socios         = datos_sa[, "gdp_socios"],
gdp_agro           = datos_hp_cycle[, "gdp_agro_pc"],
gdp_resto          = datos_hp_cycle[, "gdp_resto_pc"],
cons               = datos_hp_cycle[, "cons_pc"],
invest             = datos_hp_cycle[, "invest_pc"],
reer               = datos_sa[, "reer"],
employment         = datos_hp_cycle[, "employment"]
)
# Estimar VAR con p=1 (según HQC)
modelo_var <- VAR(df_var, p = 1, type = "const")
# IRFs con identificación recursiva: shock en smdi
irfs <- irf(modelo_var, impulse = "smdi", response = colnames(df_var),
n.ahead = 20, boot = TRUE, ci = 0.95, runs = 1000)
# Plotear IRFs
plot(irfs)
lag_selection <- VARselect(df_var, lag.max = 4, type = "const")
lag_selection$criteria
lag_selection <- VARselect(df_var, lag.max = 10, type = "const")
lag_selection$criteria #me quedo con 1
remove(list = ls(all.names = TRUE))
gc()
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("PS3_Data.R")
rer <- log(er / pc)
ner <- log(er)
remove(pcom, er, pc)
Yl.f <- 100 * cbind(rer, ner)
Yd.f <- diff(Yl.f) # log-diff transformation
remove(rer, ner)
Yl <- window(Yl.f, start = c(2003, 01), end = c(2019, 12))
Yd <- window(Yd.f, start = c(2003, 01), end = c(2019, 12))
library(vars)
Y <- Yd
# Lag Order Selection
pmax <- 12 # Maximum lag order
popt <- VARselect(Y, lag.max = pmax, type = "const")
popt
p <- popt$selection[2] # HQIC
# Lag Order Selection
pmax <- 4 # Maximum lag order
popt <- VARselect(Y, lag.max = pmax, type = "const")
popt
p <- popt$selection[2] # HQIC
p
Y <- ts(Y[(pmax - p + 1):nrow(Y), ], end = end(Y),
frequency = frequency(Y)) # Starting in Jan-05
VAR <- VAR(Y, p = p, type = "const")
m <- VAR$K # Number of variables in the VAR
T <- VAR$obs # Number of effective sample observations, excluding "p" starting values
# Model Checking
roots(VAR, modulus = TRUE)
h.BG <- 6
serial.test(VAR, lags.bg = h.BG, type = "ES")
colnames(Y) <- c("smdi", "gdp_socios", "gdp_agro", "gdp_resto", "cons", "invest", "reer", "employment")
Y <- df_var
df_var <- cbind(
smdi               = datos_sa[, "smdi"],
gdp_socios         = datos_sa[, "gdp_socios"],
gdp_agro           = datos_hp_cycle[, "gdp_agro_pc"],
gdp_resto          = datos_hp_cycle[, "gdp_resto_pc"],
cons               = datos_hp_cycle[, "cons_pc"],
invest             = datos_hp_cycle[, "invest_pc"],
reer               = datos_sa[, "reer"],
employment         = datos_hp_cycle[, "employment"]
)
#install.packages("mFilter")
#install.packages("seasonalview")
library(readxl)
library(dplyr)
library(seasonal)
library(mFilter)
library(vars)
#Seteo directorio, limpio el environment y bajo el df
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list = ls(all.names = TRUE))
gc()
#importo lo otro
source("TP2.2_Procesamiento.R")
df_var <- cbind(
smdi               = datos_sa[, "smdi"],
gdp_socios         = datos_sa[, "gdp_socios"],
gdp_agro           = datos_hp_cycle[, "gdp_agro_pc"],
gdp_resto          = datos_hp_cycle[, "gdp_resto_pc"],
cons               = datos_hp_cycle[, "cons_pc"],
invest             = datos_hp_cycle[, "invest_pc"],
reer               = datos_sa[, "reer"],
employment         = datos_hp_cycle[, "employment"]
)
Y <- df_var
colnames(Y) <- c("smdi", "gdp_socios", "gdp_agro", "gdp_resto", "cons", "invest", "reer", "employment")
# Lag Order Selection
pmax <- 4 # Maximum lag order
popt <- VARselect(Y, lag.max = pmax, type = "const")
popt
p <- popt$selection[2] # HQIC
Y <- ts(Y[(pmax - p + 1):nrow(Y), ], end = end(Y),
frequency = frequency(Y)) # Starting in Jan-05
VAR <- VAR(Y, p = p, type = "const")
m <- VAR$K # Number of variables in the VAR
T <- VAR$obs # Number of effective sample observations, excluding "p" starting values
# Model Checking
roots(VAR, modulus = TRUE)
h.BG <- 6
serial.test(VAR, lags.bg = h.BG, type = "ES")
roots(VAR, modulus = TRUE)
AIC <- popt$selection["AIC(n)"]
AIC
AIC <- popt$selection[1]
AIC
